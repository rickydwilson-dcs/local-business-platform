# **LOCAL BUSINESS PLATFORM - ARCHITECTURAL GUIDELINES**

**Universal standards for all sites in the platform - applies to colossus-reference and all future client sites**

> These guidelines were originally developed for Colossus Scaffolding (now colossus-reference) and serve as the architectural foundation for all sites generated by this platform. All client sites should follow these patterns for consistency and maintainability.

### **üìÅ FILE STRUCTURE & ORGANIZATION**

**Strict Directory Structure:**

```
/components/ui/          - All reusable UI components
/content/locations/      - All location MDX files (.mdx only)
/content/services/       - All service MDX files (.mdx only)
/app/                    - Next.js app router pages
/public/                 - Static assets
```

**Rules:**

- ‚ùå NO components outside `/components/ui/`
- ‚ùå NO content files outside `/content/`
- ‚ùå NO mixing .tsx and .mdx in same directories
- ‚úÖ Always use established directory patterns

### **üé® STYLING STANDARDS**

**Tailwind CSS Only:**

- ‚úÖ ALL styling via Tailwind utility classes
- ‚ùå NO inline styles (style={{}} properties)
- ‚ùå NO styled-components or CSS-in-JS
- ‚ùå NO custom CSS files unless absolutely necessary

**Maintainable Styling System:**

- ‚úÖ **REQUIRED**: All repeated styling patterns must be extracted to maintainable classes in `globals.css`
- ‚úÖ **PROCESS**: Before creating new styling elements, check if similar patterns exist
- ‚úÖ **APPROVAL**: New maintainable classes must be agreed upon and added to `globals.css` before use
- ‚ùå **FORBIDDEN**: Creating similar styling patterns multiple times across components
- ‚ùå **FORBIDDEN**: Custom styling without establishing reusable classes

**Maintainable Class Examples:**

```css
/* globals.css - Approved maintainable classes */
.btn-primary {
  @apply inline-flex items-center px-6 py-3 bg-[#005A9E] text-white font-semibold rounded-lg hover:bg-[#004a85] transition-colors;
}
.card-interactive {
  @apply group relative bg-white rounded-2xl shadow-sm border border-gray-200 p-8 hover:shadow-lg hover:-translate-y-1 transition-all duration-300;
}
.section-standard {
  @apply py-16 lg:py-20;
}
```

**Component Styling:**

```tsx
// ‚úÖ CORRECT - Maintainable classes
<button className="btn-primary">Click me</button>
<div className="card-interactive">Content</div>

// ‚úÖ CORRECT - Tailwind utilities for unique styling
<div className="bg-blue-600 text-white p-4 rounded-lg">

// ‚ùå WRONG - Repeated custom patterns
<button className="inline-flex items-center px-6 py-3 bg-[#005A9E] text-white font-semibold rounded-lg hover:bg-[#004a85] transition-colors">
<button className="inline-flex items-center px-6 py-3 bg-[#005A9E] text-white font-semibold rounded-lg hover:bg-[#004a85] transition-colors">

// ‚ùå WRONG - Inline styles
<div style={{ backgroundColor: '#005A9E', color: 'white', padding: '16px' }}>

// ‚ùå WRONG - CSS-in-JS
const StyledDiv = styled.div`background: blue;`
```

**Styling Workflow:**

1. **Check existing**: Search `globals.css` for similar patterns
2. **Propose new class**: If pattern will be reused, propose maintainable class name
3. **Add to globals.css**: Create the class with `@apply` Tailwind utilities
4. **Use consistently**: Apply the class across all relevant components
5. **Document**: Add to this standards section if it establishes a new pattern

### **üß© COMPONENT ARCHITECTURE**

**UI Components:**

- ‚úÖ All reusable components in `/components/ui/`
- ‚úÖ Accept props for customization
- ‚úÖ Use TypeScript interfaces for all props
- ‚úÖ Export as named exports, not default

**Component Props Pattern:**

```tsx
// ‚úÖ CORRECT
interface ButtonProps {
  variant: "primary" | "secondary";
  children: React.ReactNode;
  className?: string;
}

export const Button = ({ variant, children, className }: ButtonProps) => {
  return (
    <button
      className={`base-classes ${variant === "primary" ? "bg-[#005A9E]" : "bg-gray-200"} ${className}`}
    >
      {children}
    </button>
  );
};
```

### **üìÇ CONTENT ARCHITECTURE PATTERNS - CRITICAL**

**UNIFIED MDX-ONLY ARCHITECTURE:**

```
‚úÖ REQUIRED - All content uses MDX as the ONLY source:
/content/services/[service].mdx       - All service content (62 files total)
/content/locations/[location].mdx     - All location content
/app/services/[slug]/page.tsx         - Dynamic routing (reads MDX only)
/app/locations/[slug]/page.tsx        - Dynamic routing (reads MDX only)
```

**Single Source of Truth:**

```tsx
// ‚úÖ CORRECT - MDX-only approach
1. Read /content/[category]/[slug].mdx file
2. Parse MDX frontmatter and content
3. Render using existing component system
4. No fallback data structures - MDX is the single source of truth
```

**PROHIBITED CONTENT PATTERNS:**

- ‚ùå Dual architecture with fallback data structures
- ‚ùå Centralized TypeScript data files (lib/locations.ts, lib/services.ts)
- ‚ùå Individual page files per content item (/app/locations/brighton/page.tsx)
- ‚ùå Content-specific loaders (/lib/brighton-content.ts)
- ‚ùå Bypassing MDX content system

**Dynamic Route Requirements:**

```tsx
// ‚úÖ REQUIRED in /app/locations/[slug]/page.tsx and /app/services/[slug]/page.tsx
export default async function ContentPage({ params }: { params: { slug: string } }) {
  // Read MDX file - single source of truth
  const mdxContent = await readMDXFile(`/content/category/${params.slug}.mdx`);

  if (!mdxContent) {
    notFound(); // Return 404 if MDX doesn't exist
  }

  // Render using MDX content only
  return renderMDXContent(mdxContent);
}
```

### **üß™ TESTING STANDARDS**

**Comprehensive Testing Framework (January 2025):**

Full test coverage using Vitest for unit and integration testing across critical application paths.

**Testing Architecture:**

```typescript
// vitest.config.ts - Vitest configuration
// vitest.setup.ts - Global test setup with jsdom
// Test files: app/api/contact/__tests__/, lib/__tests__/
```

**Test Coverage:**

- ‚úÖ **Contact API Tests** (13 tests) - Form validation, email handling, rate limiting integration
- ‚úÖ **Rate Limiter Tests** (17 tests) - Redis mocking, IP isolation, error handling, fail-open design
- ‚úÖ **Content Schema Tests** (21 tests) - Zod validation for service/location frontmatter
- ‚úÖ **Location Utils Tests** (17 tests) - Location detection helpers and area served logic

**Total: 68 passing tests** executing in ~2 seconds with ~95ms actual test time.

**npm Scripts:**

```bash
# Run all tests
npm test

# Watch mode for development
npm run test:watch

# Generate coverage report
npm run test:coverage

# Interactive test UI
npm run test:ui
```

**CI Integration:**

Tests run automatically in GitHub Actions CI pipeline before every deployment, ensuring:

- No regressions in contact form functionality
- Rate limiting works correctly across environments
- Content validation catches MDX errors
- Location detection logic remains accurate

**Mocking Strategy:**

- **Upstash Redis**: Mocked for rate limiter tests
- **Resend Email**: Mocked for contact API tests
- **File System**: Mocked for content validation tests

### **‚úÖ CONTENT VALIDATION STANDARDS**

**Automated Content Quality Enforcement (January 2025):**

All MDX content files are validated using Zod schemas to ensure consistency and quality before deployment.

**Validation Architecture:**

```typescript
// lib/content-schemas.ts - Zod validation schemas
- ServiceFrontmatterSchema: Validates all service MDX files
- LocationFrontmatterSchema: Validates all location MDX files
- scripts/validate-content.ts: CLI validation tool
```

**Validation Rules:**

- ‚úÖ **Description Length**: 50-200 characters for SEO optimization
- ‚úÖ **FAQ Requirements**: 3-15 FAQs per service (mandatory)
- ‚úÖ **YAML Syntax**: Proper array formatting and field structure
- ‚úÖ **Required Fields**: All mandatory frontmatter fields must be present
- ‚úÖ **Type Safety**: Validates data types and formats

**npm Scripts:**

```bash
# Validate all content files (62 total)
npm run validate:content

# Validate services only (25 files)
npm run validate:services

# Validate locations only (37 files)
npm run validate:locations
```

**Pre-Commit Enforcement:**

Content validation runs automatically via Husky pre-commit hook:

```bash
# .husky/pre-commit
npm run validate:content
```

**Validation catches errors before deployment:**

- Invalid YAML syntax
- Missing required fields
- Description length violations
- FAQ count violations
- Type mismatches

**Documentation:** See `CONTENT_VALIDATION.md` for detailed validation rules and troubleshooting.

**Success Metrics:**

- ‚úÖ 62/62 content files passing validation
- ‚úÖ Zero runtime content errors
- ‚úÖ Automated quality enforcement at commit time

### **üìÑ CONTENT MANAGEMENT**

**MDX Files (Single Source of Truth):**

- ‚úÖ ALL content in appropriate `/content/` subdirectories
- ‚úÖ Use comprehensive frontmatter for metadata
- ‚úÖ Full component-mappable structure
- ‚úÖ Local customization and detailed content
- ‚úÖ Both services AND locations managed as MDX files
- ‚úÖ 62 total content files (25 services + 37 locations)
- ‚ùå NO content hardcoded in components
- ‚ùå NO centralized TypeScript data files (deleted lib/locations.ts)

**ServiceAbout Content Migration (January 2025):**

All ServiceAbout component content migrated from hardcoded TypeScript to MDX frontmatter:

- ‚úÖ **Migrated:** 200+ lines of hardcoded content from `components/ui/service-about.tsx`
- ‚úÖ **Added:** `about` section to 11 service MDX files with `whatIs`, `whenNeeded`, `whatAchieve`, `keyPoints`
- ‚úÖ **Refactored:** ServiceAbout component now reads from MDX `about` prop with fallback defaults
- ‚úÖ **Schema:** Added Zod validation for `about` field in ServiceFrontmatterSchema
- ‚úÖ **Benefits:** Content now editable by non-developers, follows MDX-first architecture

**Example Service About Section:**

```yaml
about:
  whatIs: "Access scaffolding is a temporary structure system designed to provide safe, stable working platforms..."
  whenNeeded:
    - "Building maintenance and exterior repairs"
    - "Window cleaning and replacement projects"
    - "Painting and rendering work on facades"
  whatAchieve:
    - "Safe working at height with full fall protection"
    - "Improved productivity through stable working platforms"
  keyPoints:
    - "TG20:21 compliant design ensuring latest safety standards"
    - "CISRS qualified scaffolders with extensive experience"
```

### **üìù CONTENT ACCURACY & CLAIMS**

**CRITICAL: Truthful Content Standards**

- ‚úÖ **CAPABILITIES**: Use "We can scaffold...", "Our team can work on...", "We specialize in..."
- ‚úÖ **EXPERTISE**: Describe knowledge, understanding, and ability to handle specific challenges
- ‚úÖ **QUALIFICATIONS**: Reference actual certifications (TG20:21, CISRS, etc.)
- ‚ùå **FALSE CLAIMS**: Never claim specific work history without verification
- ‚ùå **UNFOUNDED STATEMENTS**: Avoid "We've worked on...", "We regularly scaffold...", "We've completed..."

**Content Language Guidelines:**

```tsx
// ‚úÖ CORRECT - Capability focused
"We can scaffold everything from Victorian terraces to modern developments";
"Our team can handle the access challenges of narrow streets";
"We understand the requirements of conservation areas";
"We're equipped to work on heritage buildings";

// ‚ùå WRONG - Unverified claims
"We've scaffolded everything from Victorian terraces to modern developments";
"Our team regularly works on narrow street projects";
"We've completed hundreds of conservation area projects";
"We've worked on heritage buildings across the city";
```

**Professional Positioning:**

- ‚úÖ Focus on **ability**, **knowledge**, **qualifications**, and **equipment**
- ‚úÖ Demonstrate **understanding** of local challenges and requirements
- ‚úÖ Highlight **compliance**, **certifications**, and **professional standards**
- ‚ùå Never fabricate **work history**, **client lists**, or **project portfolios**
- ‚ùå Avoid **specific claims** that cannot be substantiated

**Enforcement:**

- All content must be reviewed for unsubstantiated claims before publication
- Any language suggesting completed work must be verified or changed to capability language
- Location content should focus on area knowledge and ability to serve, not claimed work history

**Frontmatter Standard:**

```yaml
---
title: "Page Title"
description: "SEO description"
keywords: ["keyword1", "keyword2"]
hero:
  title: "Hero Title"
  description: "Hero description"
about:
  whatIs: "Detailed service description..."
  whenNeeded:
    - "Use case 1"
    - "Use case 2"
  whatAchieve:
    - "Benefit 1"
    - "Benefit 2"
  keyPoints:
    - "Key point 1"
    - "Key point 2"
specialists:
  title: "Section Title"
  cards: [...]
services:
  cards: [...]
pricing:
  packages: [...]
# Full structured content here
---
```

### **üîç SEO STANDARDS**

**Meta Data Requirements:**

```tsx
// ‚úÖ EVERY page must have
export const metadata: Metadata = {
  title: "Primary Keyword | Brand Name",
  description: "150-160 character description with target keywords naturally integrated",
  keywords: ["primary-keyword", "secondary-keyword", "local-keyword"],
  openGraph: {
    title: "Social sharing title",
    description: "Social description",
    images: ["/images/og-image.jpg"],
    url: "https://domain.com/page-url",
  },
  twitter: {
    card: "summary_large_image",
    title: "Twitter title",
    description: "Twitter description",
  },
  alternates: {
    canonical: "https://domain.com/page-url",
  },
};
```

**SEO Content Rules:**

- ‚úÖ H1 tag must contain primary keyword
- ‚úÖ H2/H3 hierarchy must be logical and include related keywords
- ‚úÖ Meta descriptions 150-160 characters max
- ‚úÖ Page titles under 60 characters
- ‚úÖ Images must have descriptive alt text
- ‚úÖ Internal linking to related pages/services
- ‚ùå NO keyword stuffing
- ‚ùå NO duplicate content across pages

**Local SEO Requirements:**

```tsx
// ‚úÖ For location pages, include
title: "[Service] in [Location] | Company Name"
description: "Professional [service] in [location] - [key benefits]. [Credentials]. Free quotes 24/7."

// ‚úÖ Content must include
- Location name in H1
- Local landmarks/areas mentioned naturally
- Service + location combinations
- Local business information
```

### **üñºÔ∏è IMAGE OPTIMIZATION STANDARDS**

**Next.js 15 Image Configuration:**

Our `next.config.ts` includes optimized image settings for the scaffolding business:

```typescript
// next.config.ts - Image optimization configuration
images: {
  domains: [], // Add external domains if needed
  dangerouslyAllowSVG: true, // For logos and icons
  contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], // Responsive breakpoints
  imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], // Component-level sizes
  minimumCacheTTL: 60 * 60 * 24 * 365, // 1-year cache for performance
}
```

**Image Quality Configuration:**

Use the centralized image quality settings from `/lib/image-config.ts`:

```typescript
// lib/image-config.ts - Quality settings for 10% better compression
export const DEFAULT_IMAGE_QUALITY = 65; // Reduced from 75 for ~10% compression
export const HIGH_QUALITY = 80; // Hero images and critical visuals
export const LOW_QUALITY = 50; // Thumbnails and non-critical images

// Business-specific configurations
export const scaffoldingImageConfig = {
  project: { quality: 65, sizes: "(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" },
  hero: { quality: 80, sizes: "100vw", priority: true },
  service: { quality: 65, sizes: "(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 25vw" },
  team: { quality: 65, sizes: "(max-width: 768px) 100vw, 300px" },
};
```

**Image Component Usage:**

```tsx
// ‚úÖ CORRECT - Using quality settings and proper sizing
import Image from 'next/image';
import { getImageQuality, scaffoldingImageConfig } from '@/lib/image-config';

// Hero image with high quality
<Image
  src="/hero-scaffolding.jpg"
  alt="Professional scaffolding services in Brighton"
  width={1920}
  height={1080}
  quality={getImageQuality('hero')}
  priority={true}
  sizes={scaffoldingImageConfig.hero.sizes}
  className="w-full h-auto"
/>

// Project gallery image with optimized quality
<Image
  src="/project-example.jpg"
  alt="Residential scaffolding project in East Sussex"
  width={800}
  height={600}
  quality={getImageQuality('content')}
  sizes={scaffoldingImageConfig.project.sizes}
  className="rounded-lg"
/>

// Thumbnail with low quality for faster loading
<Image
  src="/service-thumb.jpg"
  alt="Access scaffolding service thumbnail"
  width={300}
  height={200}
  quality={getImageQuality('thumbnail')}
  sizes={scaffoldingImageConfig.service.sizes}
  className="object-cover"
/>
```

**Modern Format Support:**

Next.js 15 automatically serves WebP and AVIF formats when browsers support them:

- ‚úÖ **WebP**: ~25-35% smaller than JPEG with same quality
- ‚úÖ **AVIF**: ~50% smaller than JPEG with better quality
- ‚úÖ **Automatic fallback**: JPEG for unsupported browsers
- ‚úÖ **Progressive loading**: Built-in blur placeholders

**Image Optimization Rules:**

- ‚úÖ **Always use Next.js Image component** for all images
- ‚úÖ **Set explicit width/height** to prevent layout shift
- ‚úÖ **Use quality settings from lib/image-config.ts** consistently
- ‚úÖ **Add descriptive alt text** with keywords where natural
- ‚úÖ **Use priority={true}** for above-fold images only
- ‚úÖ **Configure responsive sizes** for different breakpoints
- ‚ùå **NO direct img tags** except for external/unoptimized images
- ‚ùå **NO hardcoded quality values** (use centralized config)
- ‚ùå **NO missing alt text** on any images

**Performance Benefits:**

- **20% smaller files**: Quality reduced from 75 to 58 (additional 10% compression)
- **Automatic format conversion**: WebP/AVIF when supported
- **Responsive images**: Correct size served per device
- **Lazy loading**: Images load as user scrolls
- **1-year caching**: Faster repeat visits

## **‚ö° PERFORMANCE OPTIMIZATION STANDARDS**

### **Critical CSS Inlining**

**Performance Strategy**: Critical above-the-fold CSS is inlined directly in `app/layout.tsx` to eliminate render-blocking CSS and reduce critical path latency by 100-150ms.

**Critical CSS Implementation:**

```typescript
// app/layout.tsx - Critical CSS inlined in <head>
const criticalStyles = `
  /* Above-the-fold styles only */
  body { /* Base styles */ }
  header { /* Header container */ }
  nav { /* Navigation */ }
  .btn-primary { /* CTA buttons */ }
  main { /* Content container */ }
`;

return (
  <html lang="en">
    <head>
      <style dangerouslySetInnerHTML={{ __html: criticalStyles }} />
    </head>
    {/* ... rest of layout */}
  </html>
);
```

**Critical CSS Rules:**

- ‚úÖ **INLINE**: Above-the-fold styles (body, header, nav, main container, primary buttons)
- ‚úÖ **RESPONSIVE**: Include mobile/desktop breakpoints for critical elements
- ‚úÖ **EXACT MATCH**: Styles must match current Tailwind output exactly
- ‚ùå **NON-CRITICAL**: Keep forms, utilities, page-specific styles in globals.css
- ‚ùå **OVER-INLINING**: Only include styles visible before user interaction

**Target Elements:**

- Body base styles (background, text color, font smoothing)
- Header layout and styling
- Navigation container and links with hover states
- Desktop phone/CTA container positioning
- Main content container responsive layout
- Primary button styling and interactions

**Performance Impact:**

- **Expected Reduction**: 100-150ms critical path latency
- **Trade-off**: ~2KB additional inline CSS for faster initial render
- **Benefit**: Above-the-fold content styled immediately without CSS blocking

### **Modern Browser Targeting**

**Build Optimization Strategy**: Target modern browsers (ES2022) to eliminate unnecessary JavaScript polyfills and reduce bundle size.

**Modern Browser Configuration:**

```typescript
// next.config.ts - Modern browser targeting
const nextConfig: NextConfig = {
  experimental: {
    forceSwcTransforms: true, // Force SWC for all transforms
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === "production",
    emotion: false,
    styledComponents: false,
  },
  webpack: (config, { isServer, dev }) => {
    if (!isServer) {
      config.target = ["web", "es2022"]; // Modern browser target
    }
    return config;
  },
};
```

**Browserslist Configuration:**

```bash
# .browserslistrc - Modern browser support
> 0.5%
last 2 Chrome versions
last 2 Firefox versions
last 2 Safari versions
last 2 Edge versions
not dead
not ie 11
```

**Modern Browser Benefits:**

- ‚úÖ **Eliminated polyfills**: Removes 11.4 KiB of unnecessary JavaScript polyfills
- ‚úÖ **ES2022 features**: Array.at, Array.flat, Object.fromEntries, String.trimStart/trimEnd
- ‚úÖ **Faster parsing**: Modern JavaScript syntax parsed natively by browsers
- ‚úÖ **Smaller bundles**: No legacy browser compatibility overhead
- ‚úÖ **95%+ compatibility**: Maintains support for vast majority of users

**Target Browser Support:**

- Chrome 90+, Firefox 87+, Safari 14+, Edge 90+
- Last 2 versions of major browsers
- Excludes Internet Explorer and completely dead browsers
- Mobile: Last 2 iOS and Android versions

**Performance Impact:**

- **11.4 KiB reduction** in JavaScript bundle size
- **Faster loading** on modern browsers
- **Better parsing performance** with native ES2022 support
- **Maintained compatibility** with 95%+ of global users

### **üìä SCHEMA MARKUP RULES**

**Required Schema Types:**

```tsx
// ‚úÖ Local Business Schema (all location pages)
const localBusinessSchema = {
  "@context": "https://schema.org",
  "@type": "LocalBusiness",
  name: "Colossus Scaffolding",
  description: "Professional scaffolding services in [location]",
  address: {
    "@type": "PostalAddress",
    addressLocality: "[City]",
    addressRegion: "[County]",
    addressCountry: "GB",
  },
  telephone: "+44-xxx-xxx-xxxx",
  url: "https://domain.com/locations/[location]",
  areaServed: "[Location] and surrounding areas",
  serviceType: "Scaffolding Services",
};

// ‚úÖ FAQPage Schema (pages with FAQs)
const faqSchema = {
  "@context": "https://schema.org",
  "@type": "FAQPage",
  mainEntity: [
    {
      "@type": "Question",
      name: "Question text",
      acceptedAnswer: {
        "@type": "Answer",
        text: "Answer text",
      },
    },
  ],
};

// ‚úÖ BreadcrumbList Schema (all pages)
const breadcrumbSchema = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  itemListElement: [
    {
      "@type": "ListItem",
      position: 1,
      name: "Home",
      item: "https://domain.com/",
    },
  ],
};
```

**Schema Implementation:**

```tsx
// ‚úÖ Add to page head
<script
  type="application/ld+json"
  dangerouslySetInnerHTML={{ __html: JSON.stringify(schemaData) }}
/>
```

**Schema Rules:**

- ‚úÖ Every location page needs LocalBusiness schema
- ‚úÖ Pages with FAQs need FAQPage schema
- ‚úÖ All pages need Breadcrumb schema
- ‚úÖ Service pages need Service schema
- ‚úÖ Use structured data testing tool to validate
- ‚ùå NO invalid or incomplete schema markup
- ‚ùå NO schema types not relevant to page content

### **üè∑Ô∏è STRUCTURED DATA STANDARDS**

**Image Requirements:**

```tsx
// ‚úÖ All images must have
<img
  src="/path/to/image.jpg"
  alt="Descriptive alt text with keywords where natural"
  width={800}
  height={600}
  loading="lazy" // except above fold images
/>
```

**Heading Hierarchy:**

```tsx
// ‚úÖ CORRECT structure
<h1>Main Page Topic</h1>
  <h2>Major Section</h2>
    <h3>Subsection</h3>
  <h2>Another Major Section</h2>
    <h3>Subsection</h3>

// ‚ùå WRONG - skipping levels
<h1>Main Topic</h1>
<h4>Subsection</h4> // Missing h2, h3
```

### **‚öõÔ∏è REACT PATTERNS**

**Component Structure:**

```tsx
// ‚úÖ CORRECT - Clean, typed, reusable
interface ComponentProps {
  title: string;
  items: Array<{ name: string; value: string }>;
}

export const ComponentName = ({ title, items }: ComponentProps) => {
  return (
    <div className="container mx-auto p-6">
      <h2 className="text-2xl font-bold mb-4">{title}</h2>
      {items.map((item) => (
        <div key={item.name} className="mb-2">
          {item.name}: {item.value}
        </div>
      ))}
    </div>
  );
};
```

## **üîí SECURITY STANDARDS**

### **API Rate Limiting with Upstash Redis**

**Distributed Rate Limiting (January 2025):**

Contact form API protection using Upstash Redis for serverless-compatible, distributed rate limiting.

**Architecture:**

```typescript
// lib/rate-limiter.ts - Upstash Redis rate limiter
export async function checkRateLimit(
  identifier: string,
  limit: number = 5,
  windowSeconds: number = 300
): Promise<{ allowed: boolean; limit: number; remaining: number; resetAt: number }>;
```

**Environment Configuration:**

```bash
# Upstash Redis credentials (required)
KV_REST_API_URL=https://your-database.upstash.io
KV_REST_API_TOKEN=your-token-here
```

**Rate Limit Configuration:**

- **Limit**: 5 requests per 5 minutes per IP address
- **Window**: 300 seconds (5 minutes)
- **Identifier**: Client IP address
- **Fail-Open Design**: Allows requests if Redis is unavailable

**Key Features:**

- ‚úÖ **Serverless Compatible**: HTTP REST API, no TCP connection pooling needed
- ‚úÖ **Distributed**: Works across multiple Lambda instances and deployments
- ‚úÖ **Persistent**: Rate limit counters survive cold starts and redeployments
- ‚úÖ **No Memory Leaks**: Replaced in-memory Map that reset on cold starts
- ‚úÖ **Auto-Expiry**: Redis TTL automatically clears old rate limit data

**API Integration:**

```typescript
// app/api/contact/route.ts
import { checkRateLimit } from "@/lib/rate-limiter";

const ip = headers().get("x-forwarded-for") || headers().get("x-real-ip") || "unknown";
const rateLimitResult = await checkRateLimit(ip);

if (!rateLimitResult.allowed) {
  return NextResponse.json(
    { error: "Rate limit exceeded. Please try again later." },
    {
      status: 429,
      headers: {
        "X-RateLimit-Limit": rateLimitResult.limit.toString(),
        "X-RateLimit-Remaining": rateLimitResult.remaining.toString(),
        "X-RateLimit-Reset": rateLimitResult.resetAt.toString(),
      },
    }
  );
}
```

**Benefits Over Previous Implementation:**

- ‚ùå **Old**: In-memory Map (reset on serverless cold starts)
- ‚úÖ **New**: Upstash Redis (persistent, distributed state)
- ‚ùå **Old**: Memory leaks with Map growth
- ‚úÖ **New**: Automatic TTL-based cleanup
- ‚ùå **Old**: Per-instance rate limiting (inconsistent)
- ‚úÖ **New**: Global rate limiting across all instances

## **üìä ANALYTICS & CONSENT MANAGEMENT STANDARDS**

### **GDPR-Compliant Consent System**

**Architecture Overview**: Professional consent management system ensuring GDPR compliance while enabling business analytics and marketing optimization.

**Core Components:**

```typescript
// components/analytics/ConsentManager.tsx - Main consent banner
// components/analytics/Analytics.tsx - Analytics initialization
// lib/analytics/types.ts - Type definitions
```

**Feature Flag System:**

```bash
# Environment Variables (Server-Side)
FEATURE_CONSENT_BANNER=true          # Shows/hides consent banner
FEATURE_ANALYTICS_ENABLED=true       # Enables analytics system
FEATURE_GA4_ENABLED=true            # Google Analytics 4
FEATURE_SERVER_TRACKING=true        # Server-side tracking
FEATURE_FACEBOOK_PIXEL=false        # Facebook/Meta Pixel
FEATURE_GOOGLE_ADS=false            # Google Ads tracking

# Public Variables (Client-Side)
NEXT_PUBLIC_GA_MEASUREMENT_ID=G-XXXXXXXXXX
NEXT_PUBLIC_FACEBOOK_PIXEL_ID=
NEXT_PUBLIC_GOOGLE_ADS_ID=
```

### **Consent Banner Implementation**

**Smart Page Detection**: Consent banner automatically hides on privacy/cookie policy pages to prevent content blocking.

```typescript
// ConsentManager component logic
const pathname = usePathname();
const isOnPolicyPages = pathname === "/privacy-policy" || pathname === "/cookie-policy";

useEffect(() => {
  if (!enabled || isOnPolicyPages) {
    setShowBanner(false);
    return;
  }
  // ... consent logic
}, [enabled, isOnPolicyPages]);
```

**Consent Categories:**

- **Essential**: Always required (functional cookies)
- **Analytics**: Google Analytics 4, performance tracking
- **Marketing**: Facebook Pixel, Google Ads (when enabled)

### **GA4 Integration Standards**

**Critical Fix - Single Page Visit Tracking**: Ensures users who accept cookies on first visit are tracked without requiring navigation.

```typescript
// Analytics.tsx - Manual page view after consent
const initializeGA4 = useCallback(() => {
  window.gtag("config", gaId, {
    send_page_view: false, // Disable automatic page view
  });

  // Manually fire initial page view after consent
  window.gtag("event", "page_view", {
    page_title: document.title,
    page_location: window.location.href,
    page_referrer: document.referrer || undefined,
  });
}, [gaId, consent]);
```

**Event Tracking System:**

```typescript
// Available hooks and functions
const { trackEvent, trackPageView, trackConversion } = useAnalytics();

// Example usage
trackConversion("quote_request", 150, "GBP", {
  service_type: "residential",
  location: "brighton",
});
```

### **Privacy & Compliance**

**Data Storage Strategy:**

- **Consent Storage**: Cookie + localStorage (1 year retention)
- **Analytics Data**: Google Analytics (26 months, configurable)
- **Cookie Consent**: PECR compliant, user-controlled

**GDPR Rights Implementation:**

```typescript
// Consent withdrawal
const withdrawConsent = () => {
  // Clear stored consent
  // Stop analytics tracking
  // Reload analytics with denied consent
};

// Data portability
const exportUserData = () => {
  // Return user's data in machine-readable format
};
```

**Legal Pages Integration:**

- `/privacy-policy` - Comprehensive GDPR privacy policy
- `/cookie-policy` - Detailed cookie usage and controls
- Automatic consent banner hiding on policy pages

### **Performance Optimizations**

**Lazy Loading Strategy**: Analytics scripts load only after consent acceptance, reducing initial bundle size.

**Consent State Management**:

```typescript
// Efficient state synchronization
const { consent, loading } = useConsent();

// Global event system for consent updates
window.dispatchEvent(new CustomEvent("consent-updated", { detail: consent }));
```

### **Development & Testing**

**Debug Mode**: Comprehensive logging for development and production testing.

```typescript
// Enable debug logging
debugMode={process.env.NODE_ENV === "development"}

// Production testing with feature flags
FEATURE_GA4_DEBUG=true  // Enables GA4 DebugView integration
```

**Testing Endpoints**:

- `/api/analytics/debug` - Feature flag status and configuration
- `/api/analytics/track` - Server-side event tracking endpoint

### **Implementation Rules**

**‚úÖ REQUIRED:**

- All analytics must respect user consent choices
- Consent banner must not block policy pages
- GA4 must fire initial page view after consent acceptance
- Feature flags must control all analytics functionality
- GDPR compliance must be maintained at all times

**‚ùå FORBIDDEN:**

- Loading analytics scripts before consent
- Tracking users without explicit consent
- Blocking policy pages with consent overlays
- Hardcoded analytics IDs (use environment variables)
- Analytics functionality without feature flag controls

**üîß MAINTENANCE:**

- Regular consent system testing across all browsers
- Quarterly GDPR compliance reviews
- Analytics data retention policy enforcement
- Performance impact monitoring and optimization

## **üö® CRITICAL: ARCHITECTURE INVESTIGATION FIRST**

**BEFORE implementing ANY feature, ALL developers (human or AI) MUST complete this mandatory investigation phase:**

### **Phase 1: Pattern Discovery (MANDATORY)**

```bash
# Step 1: Identify existing routing patterns
find app -name "*.tsx" -path "*/[slug]/*" | head -10

# Step 2: Read the relevant routing file FIRST
# For services: ALWAYS read app/services/[slug]/page.tsx BEFORE coding
# For locations: ALWAYS read app/locations/[slug]/page.tsx BEFORE coding

# Step 3: Understand the data architecture
# Check: Is content sourced from MDX files or TypeScript data structures?
# Verify: How do existing implementations actually work?
```

### **Phase 2: Architecture Pattern Confirmation (MANDATORY)**

Before writing ANY code, confirm these critical patterns:

**Services Architecture (Unified MDX-Only):**

```bash
# ‚úÖ CORRECT: Services use UNIFIED MDX-ONLY architecture
# Content Source: Rich MDX files in content/services/ (all content in frontmatter)
# Route Generation: generateStaticParams() reads MDX files to build routes
# FAQs: Stored in MDX frontmatter (3-15 items per service)
# Pattern: MDX is the single source of truth for all service content

# Structure:
# content/services/[service].mdx        ‚Üê Complete service content in frontmatter
# app/services/[slug]/page.tsx          ‚Üê Dynamic template reads MDX only
# components/ServiceFAQ.tsx             ‚Üê Reads FAQs from MDX frontmatter
# generateStaticParams()                ‚Üê Reads MDX files to build routes

# Key Features (January 2025):
# - All service content in MDX frontmatter (hero, specialists, FAQs, benefits)
# - Each service has 3-15 unique, SEO-optimized FAQs
# - No centralized TypeScript data structures
# - Single source of truth for all content

# ‚ùå WRONG: Creating centralized data files (lib/services.ts)
# ‚ùå WRONG: Dual architecture with fallback data
# ‚ùå WRONG: TypeScript data structures for content
```

**Locations Architecture (Unified MDX-Only):**

```bash
# ‚úÖ CORRECT: Locations use UNIFIED MDX-ONLY architecture
# Content Source: Rich MDX files in content/locations/[location].mdx
# Route Generation: generateStaticParams() reads MDX files to build routes
# Template: Single dynamic route app/locations/[slug]/page.tsx handles ALL locations
# Features: Conditional rendering for towns directory, hero images, pricing, etc.
# Data Flow: MDX frontmatter ‚Üí dynamic template ‚Üí conditional rendering
# Pattern: MDX is the single source of truth for all location content

# Key Features:
# - lib/locations.ts deleted (894 lines removed)
# - No fallback data structures
# - All content from MDX frontmatter only

# ‚ùå WRONG: Creating static pages like app/locations/surrey/page.tsx
# ‚ùå WRONG: Using centralized data files (lib/locations.ts deleted)
# ‚ùå WRONG: Individual location-specific components or routing
# ‚ùå WRONG: Dual architecture with fallback data
```

### **Phase 3: Implementation Path Confirmation (MANDATORY)**

**For Services:**

- [ ] Confirmed app/services/[slug]/page.tsx uses unified MDX-only architecture
- [ ] Verified existing services have comprehensive MDX frontmatter
- [ ] Checked that all service content comes from MDX files (no TypeScript data)
- [ ] Ready to create new MDX file with complete frontmatter structure

**For Locations:**

- [ ] Confirmed MDX files exist in content/locations/
- [ ] Verified existing locations follow MDX-only pattern
- [ ] Checked that routing file reads MDX content only (no fallback data)
- [ ] Confirmed lib/locations.ts was deleted (no centralized data)
- [ ] Ready to create new .mdx file with proper frontmatter

## **üîç UNIFIED ARCHITECTURE UNDERSTANDING**

This codebase uses a **CONSISTENT PATTERN** for all content types:

### **Unified MDX-Only Architecture**

- **Content Source**: Individual .mdx files in /content/services/ and /content/locations/
- **Content Structure**: Rich markdown with comprehensive frontmatter
- **Routing**: Dynamic routes read MDX files directly
- **Build Process**: generateStaticParams() reads MDX files to create routes
- **Rendering**: All content from MDX frontmatter and markdown, no fallback data
- **Pattern**: MDX is the single source of truth for both services AND locations
- **Total Files**: 62 MDX content files (25 services + 37 locations)

## **üö´ MANDATORY VIOLATION PREVENTION**

**These actions indicate you DID NOT follow the unified MDX architecture:**

### **Content Implementation Violations:**

- ‚ùå Creating centralized TypeScript data files (lib/locations.ts, lib/services.ts)
- ‚ùå Building dual architecture with fallback data structures
- ‚ùå Creating static page files like app/locations/surrey/page.tsx (DELETED - USE DYNAMIC ROUTING ONLY)
- ‚ùå Bypassing dynamic routing templates in favor of individual page files
- ‚ùå Creating individual location-specific or service-specific components or loaders
- ‚ùå Hardcoding content data instead of using MDX frontmatter
- ‚ùå Assuming services and locations use different architectural patterns

## **üéØ CORRECT IMPLEMENTATION APPROACHES**

### **Adding New Services (MDX-Only Pattern):**

```mdx
// ‚úÖ Create content/services/new-service-slug.mdx with comprehensive frontmatter

---

title: "New Service Title"
seoTitle: "New Service | Colossus Scaffolding"
description: "Service description for SEO (50-200 characters)..."
keywords: ["keyword1", "keyword2"]
heroImage: "/Service-Image.png"
hero:
title: "Professional New Service"
description: "Service benefits and value proposition..."
phone: "01424 466 661"
trustBadges: ["TG20:21 Compliant", "CHAS Accredited"]
ctaText: "Get Your Free Quote"
ctaUrl: "/contact"
specialists:
title: "New Service Specialists"
cards: [...]
benefits:

- "Benefit 1"
- "Benefit 2"
  faqs:
- question: "Question?"
  answer: "Answer..."

---

## Markdown content renders below structured sections
```

### **Adding New Locations (MDX-Only Pattern):**

```mdx
## // ‚úÖ CORRECT: Create content/locations/new-location.mdx

title: "New Location"
seoTitle: "New Location Scaffolding Services | Colossus Scaffolding"
description: "Professional scaffolding services in New Location..."
keywords: ["scaffolding new-location", "new-location scaffolding hire"]
heroImage: "/New-Location-Scaffolding.png"
hero:
title: "Professional Scaffolding in New Location"
description: "Local expertise for New Location's unique challenges..."
phone: "01424 466 661"
trustBadges: ["TG20:21 Compliant", "CHAS Accredited"]
ctaText: "Get Your Free Quote"
ctaUrl: "/contact"
specialists:
title: "New Location Scaffolding Specialists"
cards: [...]
services:
cards: [...]
pricing:
packages: [...]

# Towns directory for counties only

towns:
title: "New Location Towns We Serve"
townsList: [...]

---

## Markdown content renders below structured sections
```

**Key Features of Unified MDX Architecture:**

- ‚úÖ Single source of truth for all content (services AND locations)
- ‚úÖ Automatic hero image display via heroImage frontmatter
- ‚úÖ Conditional rendering of sections based on frontmatter presence
- ‚úÖ Structured sections (specialists, services, pricing, FAQs) via frontmatter
- ‚úÖ Dynamic routing templates handle all variations
- ‚úÖ No centralized data files required (deleted lib/locations.ts)
- ‚úÖ Consistent pattern across all content types

## **‚ö° IMMEDIATE VIOLATION DETECTION**

If you create any of these patterns, you have violated the unified MDX architecture:

```bash
# üö® CONTENT ARCHITECTURE VIOLATIONS (Delete immediately):
lib/locations.ts                    # Centralized location data (DELETED)
lib/services.ts                     # Centralized service data
app/locations/brighton/page.tsx     # Static location page files
app/services/scaffolding/page.tsx   # Static service page files
lib/brighton-data.ts                # Location-specific data files
lib/service-data.ts                 # Service-specific data files

# üö® These indicate dual architecture anti-pattern:
# - Fallback data structures in lib/
# - TypeScript data files instead of MDX
# - Static pages instead of dynamic routing
```

## **üîß VIOLATION RECOVERY PROCESS**

If violations are discovered:

1. **STOP all development immediately**
2. **DELETE violation files** listed above
3. **READ the correct architecture patterns** in existing code
4. **RESTART implementation** following established patterns
5. **VERIFY implementation** matches existing content type

## **‚úÖ ARCHITECTURE DISCOVERY CHECKLIST**

Before ANY content implementation:

- [ ] **Read existing routing file** for the content type
- [ ] **Confirm MDX-only architecture** (no fallback data structures)
- [ ] **Verify content structure** matches existing MDX frontmatter patterns
- [ ] **Identify MDX frontmatter requirements** for the content type
- [ ] **Verify no architectural violations** in planned approach
- [ ] **Test implementation** matches established patterns

## **üéØ SUCCESS CRITERIA**

Your implementation is correct when:

**Services:**

- [ ] New .mdx file created in content/services/ with comprehensive frontmatter
- [ ] All service data in MDX frontmatter (title, description, hero, specialists, FAQs, etc.)
- [ ] Service follows established MDX pattern (not TypeScript data structures)
- [ ] Service page renders using dynamic routing template
- [ ] generateStaticParams() can find the service MDX file
- [ ] No centralized data files created for the service

**Locations:**

- [ ] New .mdx file created in content/locations/ with comprehensive frontmatter
- [ ] All location data in MDX frontmatter (hero, specialists, services, pricing, etc.)
- [ ] Content follows established MDX frontmatter pattern
- [ ] Location renders via existing dynamic routing template
- [ ] No centralized data files created for the location

## **üö® ENFORCEMENT PRIORITY**

This discovery protocol is **MORE IMPORTANT** than any feature request. If asked to implement something that violates architecture patterns, you must:

1. **Refuse to implement** the violating approach
2. **Explain the architectural requirement** to follow established patterns
3. **Propose the correct approach** based on discovery findings
4. **Implement only** using established architectural patterns

**NO EXCEPTIONS:** Architecture consistency prevents the exact chaos we experienced with multiple AI instances creating incompatible implementations.

### **üö´ WHAT NOT TO DO**

**Banned Practices:**

- ‚ùå Inline styles anywhere
- ‚ùå Components outside `/components/ui/`
- ‚ùå Hardcoded content in components
- ‚ùå Custom CSS unless approved
- ‚ùå Any styling not using Tailwind
- ‚ùå **Repeated styling patterns without maintainable classes**
- ‚ùå **Creating new styling elements without checking globals.css first**
- ‚ùå Default exports for UI components
- ‚ùå Props without TypeScript interfaces
- ‚ùå Pages without proper meta data
- ‚ùå Missing or invalid schema markup
- ‚ùå Images without alt text
- ‚ùå Broken heading hierarchy
- ‚ùå **CRITICAL: Using centralized data as primary content source (locations)**
- ‚ùå **CRITICAL: Individual location page files**
- ‚ùå **CRITICAL: Content-specific loaders**
- ‚ùå **CRITICAL: Implementing services without architecture discovery first**

### **‚úÖ QUALITY CHECKLIST**

**Before completing any task, verify:**

- [ ] **MANDATORY: Architecture Discovery Protocol completed first**
- [ ] All new components in `/components/ui/`
- [ ] All styling uses Tailwind classes only
- [ ] **Styling:** All repeated patterns extracted to maintainable classes in `globals.css`
- [ ] **Styling:** No duplicate styling patterns across components
- [ ] **Styling:** New styling elements checked against existing classes first
- [ ] All props have TypeScript interfaces
- [ ] No inline styles anywhere
- [ ] Content in appropriate `/content/` directory
- [ ] Consistent with existing patterns
- [ ] No hardcoded content in components
- [ ] **SEO:** Proper meta data included
- [ ] **SEO:** H1/H2/H3 hierarchy correct
- [ ] **SEO:** Images have alt text
- [ ] **Schema:** Appropriate schema markup added
- [ ] **Schema:** Schema validates with testing tools
- [ ] **Accessibility:** WCAG AA compliance maintained
- [ ] **CRITICAL:** Services use unified MDX-only architecture (comprehensive frontmatter)
- [ ] **CRITICAL:** Locations use unified MDX-only architecture
- [ ] **CRITICAL:** No Architecture Violations: Implementation follows unified MDX pattern
- [ ] **CRITICAL:** Route generation works (all content from MDX files)
- [ ] **CRITICAL:** No centralized TypeScript data files (lib/locations.ts deleted)

### **üîÑ REFACTORING PRIORITY**

**When modifying existing code:**

1. **Complete architecture discovery first** - Understand existing patterns
2. **Fix architecture violations** - Ensure unified MDX-only pattern
3. **Fix styling** - Remove inline styles, use Tailwind
4. **Move components** - Relocate to `/components/ui/` if reusable
5. **Extract content** - Move hardcoded content to MDX frontmatter
6. **Add TypeScript** - Ensure all props are typed
7. **SEO audit** - Add missing meta data and schema
8. **Accessibility check** - Ensure compliance maintained

### **üìã EXAMPLE TASK COMPLETION**

**When asked to "create service pages":**

1. ‚úÖ **FIRST:** Complete Architecture Discovery Protocol
2. ‚úÖ **DISCOVER:** Services use unified MDX-only architecture
3. ‚úÖ **IMPLEMENT:** Create comprehensive MDX file in content/services/[service].mdx
4. ‚úÖ **STRUCTURE:** Include all required frontmatter (title, description, hero, specialists, FAQs, etc.)
5. ‚úÖ **VERIFY:** generateStaticParams() can find the service MDX file
6. ‚úÖ **TEST:** Service page renders with content from MDX frontmatter
7. ‚úÖ **VALIDATE:** No centralized data files created (no lib/services.ts)
8. ‚úÖ **VALIDATE:** No architectural violations exist

**When asked to "create location pages":**

1. ‚úÖ **FIRST:** Complete Architecture Discovery Protocol
2. ‚úÖ **DISCOVER:** Locations use unified MDX-only architecture
3. ‚úÖ **IMPLEMENT:** Create comprehensive MDX file in `/content/locations/[location].mdx`
4. ‚úÖ **STRUCTURE:** Include all required frontmatter (hero, specialists, services, pricing, etc.)
5. ‚úÖ **VERIFY:** Dynamic route reads MDX files as single source of truth
6. ‚úÖ Use existing components with Tailwind classes only
7. ‚úÖ Include comprehensive local content and knowledge
8. ‚úÖ Add appropriate schema markup from MDX frontmatter
9. ‚úÖ Include proper heading hierarchy and local SEO
10. ‚úÖ Add descriptive alt text to any images
11. ‚úÖ **TEST:** Pages render from MDX content (no fallback data)
12. ‚úÖ Validate schema with Google's testing tool
13. ‚úÖ **VALIDATE:** No centralized data files created (lib/locations.ts deleted)
14. ‚úÖ Verify no architecture violations exist

### **üõ†Ô∏è TESTING REQUIREMENTS**

**Before marking task complete:**

- [ ] **CRITICAL:** Architecture Discovery Protocol completed and documented
- [ ] **CRITICAL:** Implementation follows unified MDX-only architecture
- [ ] **Lighthouse SEO score:** 95+
- [ ] **Schema validation:** Pass Google's Rich Results Test
- [ ] **Accessibility:** Pass WCAG AA (contrast, alt text, headings)
- [ ] **Mobile responsive:** All breakpoints work correctly
- [ ] **Core Web Vitals:** LCP, CLS, FID within Google's thresholds
- [ ] **Services:** Content from MDX frontmatter renders properly
- [ ] **Services:** Route generation works (MDX files exist with comprehensive frontmatter)
- [ ] **Locations:** MDX content displays correctly (no fallback data structures)
- [ ] **Components:** All sourced from `/components/ui/`
- [ ] **Architecture:** No centralized TypeScript data files created

### **‚ö†Ô∏è CRITICAL ARCHITECTURE RULES**

**UNIFIED MDX-ONLY CONTENT SYSTEM:**

- ‚úÖ **SINGLE SOURCE:** MDX files with comprehensive frontmatter for ALL content
- ‚úÖ **SERVICES:** Rich MDX files in content/services/ (25 files)
- ‚úÖ **LOCATIONS:** Rich MDX files in content/locations/ (37 files)
- ‚úÖ **DYNAMIC ROUTING:** Dynamic route templates read MDX files only
- ‚úÖ **62 TOTAL FILES:** All content managed as MDX
- ‚ùå **NEVER:** Use centralized TypeScript data files (lib/locations.ts, lib/services.ts)
- ‚ùå **NEVER:** Create individual page files per content item
- ‚ùå **NEVER:** Create content-specific loaders or data structures
- ‚ùå **NEVER:** Build dual architecture with fallback data

**VIOLATION DETECTION:**
Any of these files indicate architecture violations and must be corrected immediately:

**Content Architecture Violations (DELETE IMMEDIATELY):**

- `/lib/locations.ts` (DELETED - centralized location data)
- `/lib/services.ts` (centralized service data)
- `/app/locations/[specific-location]/page.tsx` (any static location pages)
- `/app/services/[specific-service]/page.tsx` (any static service pages)
- `/lib/[specific-location]-content.ts` (location-specific data files)
- `/lib/[specific-service]-data.ts` (service-specific data files)
- `/components/[location]-specific-component.tsx` (location-specific components)

**Architectural Anti-Patterns:**

- Dual architecture with fallback data structures
- TypeScript data files instead of MDX frontmatter
- Static page files instead of dynamic routing templates
- Content-specific loaders or data structures

**ENFORCEMENT:**
These rules are MANDATORY and NON-NEGOTIABLE. The unified MDX-only architecture must be maintained. Any violations must be corrected immediately before proceeding with any other work. The Architecture Discovery Protocol MUST be completed before any implementation begins.
